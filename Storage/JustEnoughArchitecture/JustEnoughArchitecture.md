

<br/>

# 적정 소프트웨어 아키텍처(리스크 주도 접근법) - 조지 페어뱅크스

<br/>

<img src="assets/justEnoughArchitectureImage.jpeg">


<br/>



#

### Chapter01. 개요

<br/>

>32p<br/>
> 운동코치는 신인 선수보다 많은 것을 본다. 코치의 눈이 더 예리해서가 아니라 무형의 무기가 있기 때문이다.<br/>
코치는 이미 '정신적 추상화(mental abstraction)'가 구축되어 있기 때문에 더 잘 이해한다.

<br/>

>32p<br/>
소프트웨어 복잡성을 성공적으로 해결하려면 개발자에게 개선된 무기가 필요하다.<br/>
>바로 **분할(partition), 지식(knowledge), 추상화(abstraction)** 세 가지 범주이다.

<br/>

> 33p <br/>
> 소프트웨어 개발의 어려움을 해결할 실버불릿을 기대해서는 안 된다.<br/>
대신 시스템을 더 잘 분할하고 지식을 제공하고, 추상화로 문제의 본질을 드러내는 무기를 찾아야한다.

<br/>

>36p <br/>
>아키텍처 전문가는 각 시스템 분할의 차이를 알 수 있다. 코드 청크, 런타임 청크(컴포넌트), 하드웨어 청크(노드/환경요소)를 구분할 수 있다. <br/>
>아키텍쳐 전문가는 도메인 사실, 설계 결정, 구현 세부정보를 구분하고 묶을 수 있다. 다른 사람이 이를 뒤섞어 놓았더라도 구분할 수 있다. <br/>

<br/>

> 37p <br/>
개발자들은  결과물을 생성하려고 실행되는 프로그램을 정적인 문장으로 만든다. <br/>
정적인 문장으로 표현된 프로그램은 동적으로 어떻게 실행될지 예측하기 어렵다 <br/>
Goto문은 코드가 런타임에 어떻게 실행되는지 예측하기 어려우므로 Goto문은 피하고 구조적 프로그래밍으로 만드는 방법이 가장 좋다.

<br/>


> 40p <br/>
> 아키텍쳐링에 투입할 노력은 소프트웨어 개발의 실패 리스크에 따라 달라져야 한다. <br/>
수행할 웹 서비스가 인기 있다면 시스템은 규모확장성(scability)이란 요구사항을 충족해서 많은 사용자를 지원해야 한다. <br/>
> 설계에 너무 많은 에너지를 투자하기 전에 시스템이 예상 사용자 수를 처리할 수 있는지 확인해야한다. <br/>
> 반대로 시스템의 수정 가능성이 덜 염려된다면 해당 리스크에 소중한 시간을 허비하지 않아도 된다. <br/>

<br/> 

# 

### Chapter02. 소프트웨어 아키텍쳐

<br/>

> 47p <br/>
> 아키텍처가 시스템의 골격 역할을 하고 품질 속성에 영향을 미치며, 시스템을 제한하기 때문에 소프트웨어 아키텍처 선택이 중요하다.<br/>
아키텍처 대부분은 시스템에서 제공해야하는 기능과 직교한다. 즉, 상관관계가 없다. <br/>
> 하지만 더 잘 동작하는 조합도 있다. 아키텍처 설계는 이렇게 잘 동작하는 부분을 찾는 작업이다. <br/>

<br/>

>50p<br/>
>일부 낮은 수준의 세부사항까지 도달하는 아키텍트의 몇가지 높은 수준의 의도나 결정에서 일련의 의도가 존재한다 <br/>

<br/>

>51p<br/>
>아키텍처는 시스템을 제한한다. 아키텍처는 시스템이 원하는 품질 속성을 갖도록 충분한 제약을 부과하는 기술이다.<br/>
예를 들어 확장성을 보장하는 설계에서 확장석을 달성하려면 일부 컴포넌트가 상태를 저장하지 않아야(stateless) 할 수 있다.

<br/>

>53p<br/>
>시스템이 하지 않는 일은 시스템이 하는 일만큼 중요하다. <br/>
시스템에 요구되는 품질이 보장되는지 확인하려면 시스템이 수행하지말아야 하는 작업을 알고 제약해야 한다.<br/>
> 예를 들어 보안 시스템은 신뢰할 수 없는 당사자와 데이터를 교환하지 않아야 한다.<br/>

<br/>

>54p<br/>
>판단을 구체화한다. 제약 조건은 한 개발자가 다른 개발자에게 지혜나 이해를 전달하는 수단이다. <br/>
설계의 제약사항을 활용해 지식을 직접적으로 전달하지 않고도 수용가능한 해결책을 다른 엔지니어가 만들도록 할 수 있다.<br/>
아키텍처 제약은 불필요한 창의성 소모를 감소시킬 수 있다.<br/>

<br/>

>54p<br/>
>아키텍쳐를 통해 런타임 동작을 이해하고 예측할 수 있다.<br/>
이해하기 까다로운 런타임 동작 소스 코드에는 아키텍처를 통해 '제약'을 부과한다.<br/>

<br/>

>56p<br/>
>오늘날 많은 도메인에는 이와 유사한 지배적인 소프트웨어 아키텍처가 존재한다. 이를 추정아키텍처(Presumptive architecture)라고 한다 <br/>
>추정 아키텍처는 특정 도메인에서 지배적인 아키텍처군이다. 도메인의 일반적인 리스크에 잘 맞기 때문에 '사실상 표준'으로 사용한다.<br/>

<br/> 

# 

### Chapter03. 리스크 주도 모델 

<br/>

>71p<br/>
성공적인 소프트웨어를 만들 때, 소프트웨어 개발자는 여러 안건 중에서 실패가 예상되는 설계를 버리고 실패 리스크가 적은 옵션을 선택한다.<br/>
>**실패 개념이 설계 프로세스의 핵심이다.** 실패를 제거하는 관점에서 생각함으로써 성공적인 설계가 만들어진다.<br/>

<br/>

>72p
>리스크 주도 모델의 핵심 아이디어는 소프트웨어 아키텍처를 설계하는 데 드는 노력이 프로젝트의 리스크에 비례해야 한다는 것이다.<br/>
리스크 주도 모델은 '소프트웨어 아키텍처에 얼마나 많은 시간을 사용해야 하는가?' 그리고 '어떤 기법을 사용해야 하는가?'라는 두 가지 질문에 도움을 준다.<br/>
리스크 주도 모델은 리스크를 눈에 띄게 홍보하는 것이 핵심이다.<br/>

<br/>

>75p<br/>
>개발자가 리스크에 맞추어 아키텍처 활동을 수행하지 못하면, 아키텍처링 기법을 과도하게 사용하거나 적게 사용하는 상황을 만들게 된다.<br/>

<br/>

>76p<br/>
>엔지니어링 맥락에서 리스크는 일반적으로 실패가능성 x 해당 실패의 영향으로 정의한다.<br/>
다시말해 **리스크 = 인지한 실패 확률 x 인지한 영향** 이다<br/>

<br/>

>77p<br/>
>숙련된 개발자는 엔지니어링 리스크를 쉽게 찾아낼 수 있지만 개발자가 경험이 부족하거나 익숙하지 않은 도메인에서 작업할 때는 어떻게 해야 할까?<br/>
어떤 형태이든지 요구사항을 가지고 시작하는 방법이 가장 쉽다. **가장 달성하기 어려운 요구사항을 찾아야한다**<br/>
>잘못 이해하거나 불완전한 품질 속성을 포함한 요구사항은 일반적인 리스크의 예이다<br/>
>

<br/>

>96p
>안전한 애플리케이션을 원한다면 조기에 리스크를 해결해야 한다고 제품 책임자에게 교육하는 것이 소프트웨어 개발자의 임무이다.<br/>
>나중에 추가하여 만들기가 어렵거나 불가능하기 때문이다. 각 반복이 끝날 때 회고의 결과로 아키텍처 리스크를 평가하고 이를 백로그에 입력해야한다.<<br/>/>


<br/>

> 

<br/> 

# 

### Chapter04. 예제: 홈 미디어 플레이어

<br/>

<br/> 

# 

### Chapter05. 모델링 관련 조언

<br/>

<br/> 

# 

### Chapter06. 엔지니어가 사용하는 모델

<br/> 

<br/>

# 

### Chapter07. 소프트웨어 아키텍처의 개념 모델

<br/> 

<br/>

# 

### Chapter08. 도메인 모델

<br/> 

<br/>

# 

### Chapter09. 디자인 모델




